<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c6{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c5{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{color:inherit;text-decoration:inherit}.c7{font-weight:700}.c1{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5 doc-content"><p class="c0"><span class="c3">Website Link:</span></p><p class="c0 c1"><span class="c3"></span></p><p class="c0"><span class="c6"><a class="c4" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-GarciaEricS/hw2/index.html&amp;sa=D&amp;source=editors&amp;ust=1709040116666871&amp;usg=AOvVaw25um38Ou1R9dLiHWeS3G49">https://cal-cs184-student.github.io/hw-webpages-sp24-GarciaEricS/hw2/index.html</a></span></p><p class="c0 c1"><span class="c3"></span></p><p class="c0"><span class="c3">Overview:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">In this assignment, we implemented de Castejiau&rsquo;s algorithm for implementing Bezier curves from control points through recursive subdivision. We extended this to surfaces in 3d by applying the algorithm multiple times in different directions to control points in 3d space.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Next, we implemented edge splitting and edge flipping in orientable manifold meshes made of triangles allowing us to change the geometry and topology of existing meshes. Finally, we implemented Loop subdivision to create a smooth surface from a control cage, using the edge splitting and flipping heavily in our implementation.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Overall, it was really interesting to see how easily the theoretical geometry in class translates to real meshes. With some relatively simple math pointer manipulation, we could create really nice-looking meshes, curves, and surfaces that are as smooth as we desire. Also, it was interesting to see how geometry is handled in a program through the half-edge data structure. In lecture, it seemed obtuse, but we learned it&rsquo;s actually quite pleasant to work with.</span></p><p class="c0 c1"><span class="c3"></span></p><p class="c0"><span class="c3">Part 1: </span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">De Casteljau&rsquo;s algorithm is a method for going from control points to a bezier curve through recursive subdivision. Basically, you consider a linear interpolation of two adjacent control points using the parameter t which gives you a new control point. You do this for all sets of adjacent control points, using the same lerp parameter (t) to construct a new control point from each pair. Now using the same t, you repeat the process recursively with your new control points until you reach just one point. This is one point on your bezier curve. Varying t from 0 to 1 gives you the whole bezier curve between the control points.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">We implemented de Castejau&rsquo;s algorithm by looping over all pairs of adjacent control points. From there, we compute the linear interpolation of each pair for a given parameter t. We return the new control points in a vector. The other implementation for the algorithm, such as varying t and running the recursion with the new control points is handled elsewhere in the program.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Our created control points (default t level):</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 691.50px; height: 375.72px;"><img alt="" src="images/image4.png" style="width: 691.50px; height: 375.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">1 Level of Subdivision:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 690.92px; height: 375.15px;"><img alt="" src="images/image5.png" style="width: 690.92px; height: 375.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">2 Levels of Subdivision</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 690.13px; height: 374.72px;"><img alt="" src="images/image18.png" style="width: 690.13px; height: 374.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">3 Levels of Subdivision:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.34px; height: 374.29px;"><img alt="" src="images/image21.png" style="width: 689.34px; height: 374.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">4 Levels of Subdivision:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 686.71px; height: 372.86px;"><img alt="" src="images/image11.png" style="width: 686.71px; height: 372.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">5 Levels of Subdivision (contains a point on the curve):</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 686.50px; height: 372.75px;"><img alt="" src="images/image19.png" style="width: 686.50px; height: 372.75px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span>Curve from Shifted Control Points and Red Point on Curve from Modified t:<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 685.50px; height: 372.21px;"><img alt="" src="images/image15.png" style="width: 685.50px; height: 372.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c7">Part 2:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">The de Casteljau algorithm can be extended to evaluating a point (u, v) on a Bezier surface parameterized by points Pij (with 0 &lt;= i, j &lt;= n-1). We do this by first computing points P&rsquo;i = evaluate1D([Pi0, Pi1, &hellip;, Pi(n-1)], u) for all i from 0 to n-1. In doing this, we use the de Casteljau algorithm for evaluating 1D Bezier curves on the ith row of our control points (treated as the control points for a 1D Bezier curve) with interpolation parameter u. Then, we return the value computed by evaluate1D([P&rsquo;0, P&rsquo;1, &hellip;, P&rsquo;(n-1)], v), which also uses the 1D de Casteljau algorithm on the previously computed points P&rsquo;i with interpolation parameter v. To summarized, we perform 1D de Casteljau n+1 times, n times to compute intermediate points on the Bezier curve defined by every row of control points, and once to evaluate the Bezier curve given by the intermediate points.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Here is an image of the teapot evaluated by our implementation:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.50px; height: 431.18px;"><img alt="" src="images/image17.png" style="width: 689.50px; height: 431.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c3">Part 3:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">We implemented area-weighted vertex normals by first iterating over all faces that vertex is a part of. We did this by iterating over each half edge exiting from that vertex. We knew that each half edge belongs to exactly one face, so looping over all half-edges exiting from that vertex would effectively be looping over all the faces. Then, we find the vectors pointing from our original vertex to the other vertices in the face we&rsquo;re iterating over. Finding the cross product between these two vectors (making sure the order is correct using our knowledge about how sequential half-edges move counterclockwise and using the right-hand rule) gives us the normal vector of the face scaled by two times the face&rsquo;s area by properties of the cross product.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Adding up all of the vectors scaled by two times the corresponding faces area gives us a normal vector weighted by two times the faces&rsquo; areas. Then we normalize, removing the effect of the factor of two and leaving a normal vector for the vertex that&rsquo;s a normalized weighted sum of its adjacent faces&rsquo; areas.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span>Flat Shading:<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 687.52px; height: 373.30px;"><img alt="" src="images/image12.png" style="width: 687.52px; height: 373.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Phong Shading:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 690.41px; height: 374.87px;"><img alt="" src="images/image3.png" style="width: 690.41px; height: 374.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c7">Part 4:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span>We implemented the edge flip operation as follows: First, we check if the edge is on the boundary and if it is, return the edge unaltered. Otherwise, we first collect all the relevant </span><span>halfedges</span><span class="c2">, vertices, edges, and faces that we will need to mutate. Then, we update the relevant pointers on each of these items to flip the edge. The only interesting part of our implementation is that it only updates the fields that need to be updated at least sometimes (i.e. it will never update a field if the field will absolutely never need to be updated to perform an edge flip). There was not much debugging required to implement this correctly.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Teapot Before Edge Flips:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 688.46px; height: 430.28px;"><img alt="" src="images/image22.png" style="width: 688.46px; height: 430.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Teapot After Edge Flips:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.37px; height: 430.86px;"><img alt="" src="images/image9.png" style="width: 689.37px; height: 430.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c3">Part 5:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">We implemented the edge split operation essentially just by following the diagram here.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 627.50px; height: 183.59px;"><img alt="" src="images/image8.png" style="width: 627.50px; height: 183.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2">Without loss of generality, we assumed the bc edge we are given has a half-edge pointer pointing to the bc half-edge. From there, we found all relevant half-edges, vertices, and faces and gave them names according to the image on the left. Then, we created the half-edges, edges, vertices, and faces that need to be created to make the diagram on the right, repurposing existing edges, half-edges, and faces that aren&rsquo;t in the right diagram to be used in the split mesh. For example, we repurposed the bc edge as the bm edge, the abc face as the abm face, and the bc half-edge as the bm half-edge.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Then, we assigned all pointers to newly created edges, face, half-edges, and vertices to their correct values, and updated old pointers that will change (for example, the next pointer for the half-edge ca) due to the transformation.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">As for interesting implementation tricks, we didn&rsquo;t do too much beyond reusing old half-edges, edges, and faces to avoid deleting them and creating new ones. We surprisingly did not have to debug this task, so we didn&rsquo;t have any interesting debugging tricks.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Before Edge Splits:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 691.50px; height: 375.46px;"><img alt="" src="images/image10.png" style="width: 691.50px; height: 375.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">After Edge Splits:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 692.50px; height: 376.01px;"><img alt="" src="images/image20.png" style="width: 692.50px; height: 376.01px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span>After a combination of edge splits and edge flips:<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.50px; height: 374.38px;"><img alt="" src="images/image2.png" style="width: 689.50px; height: 374.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">We (thankfully) did not have a great debugging journey and we did not implement support for handling split operations on boundary edges.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c7">Part 6:</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">We implemented the Loop subdivision algorithm according to the details in the spec. Specifically, we first precompute the updated position of every vertex and every edge (corresponding to the new vertex that will be created at the midpoint of the given edge when we split the edges). Then we will split all the pre-existing edges in the mesh, marking the new vertex as new and giving its new position as the edges new position. When we do the splits, we also mark newly created edges as being new. Then, we loop over all newly created edges and flip each edge if it connects an old vertex to a newly added vertex. Finally, we will loop through all vertices and set each vertex&rsquo;s position to its precomputed new position. We didn&rsquo;t encounter much difficulty in debugging this part. One issue we ran into was when attempting to loop over only the pre-existing edges, we tried to get the end pointer of the edges list before doing additional splits; however, this pointer continued to update when we did splits, causing an infinite loop. The solution to this was to precompute the number of pre-existing edges, and only loop over this many edges when performing the splits.</span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Here is an image of a torus before Loop subdivision:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 718.50px; height: 448.82px;"><img alt="" src="images/image14.png" style="width: 718.50px; height: 448.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">And here is the same torus after Loop subdivision is executed:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 721.37px; height: 450.86px;"><img alt="" src="images/image13.png" style="width: 721.37px; height: 450.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Notice that the sharp edges and corners are completely smoothed out. To avoid this from happening, we can pre-split the faces of the mesh, which enforces the sharp edges and corners and lessens the amount that they are smoothed out. Here is the same torus after we apply this preprocessing step and then apply the Loop subdivision algorithm, we can see that the edges stay more well-defined:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 726.79px; height: 454.25px;"><img alt="" src="images/image6.png" style="width: 726.79px; height: 454.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Here is an image of a cube before Loop subdivision:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 730.91px; height: 456.82px;"><img alt="" src="images/image7.png" style="width: 730.91px; height: 456.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">And here is the same cube after performing the Loop subdivision algorithm:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 738.22px; height: 461.39px;"><img alt="" src="images/image1.png" style="width: 738.22px; height: 461.39px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c2"></span></p><p class="c0"><span class="c2">Notice that this mesh is highly asymmetrical. This happens because all the vertices in this mesh have neighboring vertices at non-uniform angles from each other (e.g., a vertex will always be connected to three vertices that you can get to by traversing an edge of the cube&rsquo;s geometry, and will be connected to two out of three vertices that you can get to by crossing over a face of the cube). We can fix this issue in the cube model by pre-splitting all the edges that lie on a face of the cube&rsquo;s geometry. This changes the mesh such that every corner vertex has edges to 6 vertices: the 3 vertices you can get to by traversing an edge of the cube&rsquo;s geometry, and the 3 vertices you can get to by crossing a face of the cube. The newly created vertices in the middle of each face of the cube also have a balanced set of neighbors, as each of these vertices is connected to the 4 corner vertices of the face of the cube that the vertex in question is in the center of. Because this process balances out the neighbors of each vertex, it results in a smoother mesh after performing Loop subdivision. Here is an image of the same cube after we preprocess the edges in the way described above and the perform Loop subdivision, notice that the resulting shape is symmetrical:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 747.22px; height: 467.01px;"><img alt="" src="images/image16.png" style="width: 747.22px; height: 467.01px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>