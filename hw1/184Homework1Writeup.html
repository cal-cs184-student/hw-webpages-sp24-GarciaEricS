<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c6{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{color:inherit;text-decoration:inherit}.c5{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><p class="c2"><span class="c5">Task 1</span><span class="c0">:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">How we rasterize triangles: </span></p><p class="c2"><span class="c0">First we reorder the pixels to ensure the winding order is correct. To do this, we first set pixel 0 to be the pixel with the lowest x coordinate. Then we calculate the slopes from point 0 to points 1 and 2, and set point 1 to be the point with the lower slope. This ensures x0 -&gt; x1 -&gt; x2 moves clockwise around the triangle. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Then, we find the bounding box of the triangle by finding the smallest and largest x locations and smallest and largest y locations. These define the corners of our box. </span></p><p class="c1"><span class="c6 c7"></span></p><p class="c2"><span class="c6">We then &nbsp;iterate through only the points in our box and check if each point is in our triangle. This ensures that we only check samples in the bounding box the triangle.</span><span class="c0">&nbsp;We implemented the logic and math detailed in lecture about checking if a point is inside a triangle with points given in correct winding order. For all the points inside the triangle, we call rasterize_point to fill in all the necessary points.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Test 4 (No Supersampling Anti Aliasing)</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 581.00px; height: 458.49px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 496.00px; margin-left: -23.00px; margin-top: -20.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3"></span></p><p class="c1"><span class="c3"></span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c3">Task 2:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">Supersampling is useful since it allows us to antialias our rasterized models. When we sample a pixel near the edge of a shape, supersampling allows us to make this pixel a variable color depending on how much of the pixel is occupied by the shape. We approximate the fraction of the pixel covered by the shape by sampling several points inside the pixel and averaging the sampled values at these points. This anti-aliases the image by blurring all the edges, which acts as a low pass filter on our image. This removes the high frequency components of the signal that are the cause of aliasing.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The data structure we used is a sample buffer of size width * height * sample_rate. This is represented as a vector of Color objects. The initial grid sampling algorithm is as follows. For every point (x, y) we consider breaking the corresponding pixel into a grid of size sqrt(sample_rate) * sqrt(sample_rate). We will sample the centers of each of the squares in the grid, and store the sampled values in the sample buffer. Then, when the sample buffer is resolved to the frame buffer, we will take the average of the first floor(sqrt(sample_rate)) ** 2 entries in the sample buffer corresponding to each pixel, and use this value as the color to put in the frame buffer at that pixel. (We only consider the first floor(sqrt(sample_rate)) ** 2 entries because these are the entries filled by rasterize_triangle. If the sample rate is not a perfect square, then the rasterize_triangle method will leave some of the slots in the sample buffer empty. If we considered these in the downsampling step, it would make the color in our image inaccurate.) </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Grid Sampling Results:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Grid Supersampling with 1 Sample per Pixel</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Grid Supersampling with 4 samples per pixel</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Grid Supersampling with 9 samples per pixel</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">For the extra credit portion, we implemented jittered sampling. Here is the link where we learned about the jittering sampling method:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4"><a class="c8" href="https://www.google.com/url?q=https://web.cs.wpi.edu/~emmanuel/courses/cs563/S10/talks/wk3_p1_wadii_sampling_techniques.pdf&amp;sa=D&amp;source=editors&amp;ust=1707801795079385&amp;usg=AOvVaw1ENEJUcwX1PMVsPpveJR-q">https://web.cs.wpi.edu/~emmanuel/courses/cs563/S10/talks/wk3_p1_wadii_sampling_techniques.pdf</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">To perform jittered sampling, we divide each pixel into a sqrt(sample_rate) x sqrt(sample_rate) grid, then uniformly select a point from each square in the grid to sample from. Here is an image from the link visualizing the effect, sampling for a pixel using sample rate of 16:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.50px; height: 517.20px;"><img alt="" src="images/image12.png" style="width: 3103.23px; height: 1944.49px; margin-left: -1302.96px; margin-top: -974.73px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">And here are the Jittered Sampling Results:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Jittered with 1 sample per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Jittered with 4 samples per pixel</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Jittered with 9 samples per pixel.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Task 3:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">Image of modified cubeman rendering:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here, we made cubeman wave his arm in a salutary gesture. To do this, we rotated the lower half of the left arm by 45 degrees and rotated the upper half by an additional 45 degrees. We also modified the translational transformations on both parts of the arm to make the pieces line up nicely with each other and the torso.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c5">Task 4:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Barycentric coordinates are a coordinate system for triangles that tell you where a coordinate is in a triangle in terms of a convex combination of the coordinates of the vertices.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">In simple terms, each coordinate has some term associated with it, and that term being higher in the coordinate system means the coordinate is closer to that point. And, all the terms for each vertex must sum to 1. Here is an example of a point where all terms are equal and you can see the point is in the &ldquo;middle&rdquo; of the triangle. We can derive barycentric coordinates from the coordinate, then use the coefficients in the convex combination to derive other useful information. For example, if we know a triangle vertices of three different colors, and we want the colors of the triangle to smoothly change as we move across the triangle, we can use barycentric coordinates to define what color at each point should be as a (convex) combination of the vertices&rsquo; colors, using the same coefficients as the barycentric coordinates for that point. Doing so yields what we see below:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 340.38px; height: 289.92px;"><img alt="" src="images/image3.png" style="width: 969.85px; height: 860.85px; margin-left: -295.31px; margin-top: -189.80px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Here is test 7 with the default parameters and sample rate of 1.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">And here is our gradient visualization which we showed earlier:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 556.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 556.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Task 5:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">Pixel sampling is a process in which we compute the relevant color for a pixel in a triangle based on its position in the triangle and the texture mappings of the vertices of the triangle. First, we compute texture coordinates (u, v) for each of the sampled points in the triangle by using the barycentric coordinates of that sampled point (we take a convex combination of the texture coordinates of each vertex in the triangle, weighted by the barycentric coordinates of the sample). Then we can sample the texture using either the nearest method or the bilinear method.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The nearest method simply computes the nearest texel to the desired texture coordinates. The bilinear method looks at the nearest four texels to the desired texture coordinates, which form a box around the desired texture coordinate. Then, we will linearly interpolate between these four texels based on the orthogonal distance in each direction from each of the four texels to the desired texture coordinates.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here is an example of when bilinear sampling defeats nearest sampling. In the next two picture, you can see the same image with nearest sampling and with bilinear sampling. Both these images have no supersampling (sample rate of 1). Clearly, we can see that the nearest sampling method makes an image with more sharp edges, or &ldquo;jaggies&rdquo;, than the bilinear method. The bilinear method, on the other hand, produces a relatively smooth texture.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We can see in the next two images the nearest method and bilinear method compared, but in these two, we have set the sample rate to 16. The bilinear method still makes the image more &ldquo;blurry&rdquo;, but this works to anti-alias the image as compared to the nearest method. Note however, that when the sample rate is high, there is much less of a stark difference between nearest sampling and bilinear sampling. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">There will be large differences between the two methods when the texture has been highly magnified or when the texture has lots of high frequency components. When the texture has been magnified, bilinear sampling will do a better job at antialiasing the texel artifacts, whereas nearest sampling will show the boundaries on the individual texels in the final render. Also, when the texture has lots of high frequency components, bilinear sampling can reduce aliasing by linearly interpolating between texels of different values, however level sampling will work even better in this case.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Task 6:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">A mipmap is multiple copies of a texture of smaller and smaller resolutions and more blurring as the mipmap level increases. Level sampling is choosing to sample from a texture with a specific level in the mipmap to make your photo look the best.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">As for pixel sampling, level sampling, and number of samples per pixel, each has the power to antialias at different rates while sacrificing at least some speed and memory. Supersampling, or taking more samples per pixel, takes more time and memory proportional to the number of samples per pixel. If we multiply the number of samples per pixel by 4, we will use approximately 4 times more time and memory. Antialiasing power is good, but gain is marginal as diminishing as we add more and more samples.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Bilinear pixel sampling does not require any additional memory besides a trivial constant amount, but it does take more time. Assuming we are sampling from a location not on the edge of our texture, we need to perform 4 lookups and 3 lerps. This will decrease our speed by a non-trivial amount, but the antialiasing power is great compared to nearest-neighbor pixel sampling. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Level sampling with level 0 has no antialiasing but is very fast and memory efficient. Level sampling at the nearest level requires calculating a discrete derivative, which is quite fast, only doing a couple additional barycentric coordinate calculations and fast operations. Overall, it is quite fast, as there is only a bit more calculations per sample. As for memory, there is of course additional memory needed to store the mipmap, but not too much as the size of the mipmap levels are geometrically decreasing. Beyond this, level sampling at nearest neighbor requires only trivially more memory than 0 level. Antialiasing power is good, but we still see some aliasing as we move between what mipmap levels we sample from in the image. Level sampling with bilinear level interpolation gets rid of this issue, having great antialiasing power as we no longer take big jumps between mipmap levels. For this, we sacrifice some speed because we double the amount of samples we have to take, and we add one extra lerp. Additional memory usage beyond the memory for nearest neighbor is negligible.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here are our PNG screenshots:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">L_ZERO and P_NEAREST:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">L_ZERO and P_LINEAR</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">L_NEAREST and P_NEAREST</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">L_NEAREST and P_LINEAR</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 496.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 496.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>