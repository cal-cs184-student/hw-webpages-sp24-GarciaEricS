<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c6{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c7{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{color:inherit;text-decoration:inherit}.c4{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c7 doc-content"><p class="c2"><span class="c3">Website Link:</span></p><p class="c2"><span class="c6"><a class="c5" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-GarciaEricS/hw3/index.html&amp;sa=D&amp;source=editors&amp;ust=1710408321437248&amp;usg=AOvVaw2_N7zxEk140Z-_l_HOzqlO">https://cal-cs184-student.github.io/hw-webpages-sp24-GarciaEricS/hw3/index.html</a></span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c4">Overview:</span></p><p class="c2"><span class="c0">For each implementation, we followed the implementations given in pseudocode in lecture and directions on the page, using few tricks. We ran into many debugging challenges throughout this project. For example, when intersecting the bounding view hierarchy, we used an &ldquo;or&rdquo; operator when seeing whether we intersected the left or the right subnode. With the or operator, we would short circuit when we found an intersection in the left node without checking if we intersected anything closer in the right box. To debug this, we looked at the rendered image and noticed that we kept rendering objects behind other objects, and realized we must have not considered the closer object. Seeing the &ldquo;or&rdquo;, we knew there was a short circuit. Other bugs were solved similarly, looking at what was wrong in the image, forming hypotheses about where this could arise, and going from there.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Overall, this project was very difficult but very fun. It was amazing seeing all the light theory from class come together to produce nice images. Debugging was difficult, but it was very worth it to produce great renders using our own software.</span></p><p class="c1"><span class="c3"></span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c3">Task 1:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">Our pipeline for ray generation and primitive intersection is as follows: For each pixel, we will generate num_samples random points in the box on the image plane corresponding to this pixel. For each of these points, we generate a ray in the world coordinate system that starts at the camera and passes through the corresponding image point in the image plane in the world coordinates. We also specify the min_t and max_t for this ray. Then, we intersect this ray with the primitives in our scene. We attempt to intersect the ray with every primitive object (triangle or sphere) in the scene, and depending on whether the ray intersects or not, we will get a color corresponding to that ray. After doing this for num_samples rays, we take their average color value and fill in that value in the sampleBuffer.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Regarding the triangle intersection algorithm, we implemented the M&ouml;ller-Trumbore intersection algorithm that was mentioned in lecture. This algorithm computes the t value at which the ray intersects the plane specified by 3 points (the vertices of the triangle) and in doing so also computes the barycentric coordinates of the point on the plane that the ray intersects with respect to the 3 points. It does this by taking dot products and cross products of the origin of the ray, the direction of the ray, the vectors corresponding to the vertices of the triangle, and the vectors corresponding to some of the edges of the triangle. After we use this algorithm to find the correct value of t and the barycentric coordinates, we check that 1) the value of t is within the desired range (min_t &lt;= t &lt;= max_t) and that each of the barycentric coordinates are in the range [0, 1] (this ensures that the point is inside the triangle). This algorithm is efficient as it only uses a single division. It is also very useful for this task because it gives the barycentric coordinates, which we can use the interpolate the normal vector at the point from the given normal vectors of the vertices.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here are a few sample images we generated:</span></p><p class="c2"><span class="c0">From dae/sky/CBGems.dae:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image45.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>From dae/meshedit/cow.dae</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 623.74px; height: 467.80px;"><img alt="" src="images/image22.png" style="width: 623.74px; height: 467.80px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">From dae/keenan/banana.dae:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.50px; height: 468.38px;"><img alt="" src="images/image43.png" style="width: 624.50px; height: 468.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">Task 2:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Our BVH construction algorithm is as follows: First, create a BVH node with a BBox that contains all the primitives between start and end in the vector (we used bbox.expand to do this). Then, if there are less primitives between start and end than the max_leaf_size, we set the BVH node&rsquo;s start and end pointers to be the start and end pointers passed into the function, and return this node. Otherwise, we attempt to split the bounding box. We first compute the average of the centroids of all the primitives. Then, we compute how many primitives would end up in the &ldquo;left&rdquo; set for each of the possible split axes (x, y, or z) given that the split point along the axis is the coordinate of the centroid average on that axis. We choose the split axis based on whichever one minimizes the absolute difference between the number of primitives in the &ldquo;left&rdquo; set and the &ldquo;right&rdquo; set (if we have n objects total, and leftSizes[i] objects would be in the &ldquo;left&rdquo; set if we split along axis i, we will choose the axis i that minimized abs(n - 2 * leftSizes[i])). After we pick a split axis, we will sort all the primitives in the vector between start and end based on the coordinate of their centroid in the split axis (e.g., if we choose the split along the z axis, we will sort the vector in increasing order of the z coordinate of the centroid of each primitive). Then, we can recurse: set the node&rsquo;s l pointer to the result of a recursive call on the &ldquo;left&rdquo; set (between start and middle) and set the node&rsquo;s r pointer to the result of a recursive call on the &ldquo;right&rdquo; set (between middle and end), where middle is equal to start + the number of primitives in the left set (which we computed earlier when deciding which axis to split on). After recursing, we will return the node.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here are a few images that can only be rendered with BVH acceleration:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">dae/meshedit/peter.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image33.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">dae/sky/dragon.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image13.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">dae/sky/CBlucy.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image39.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">dae/meshedit/maxplanck.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image17.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The BVH Acceleration makes rendering scenes with moderately complex geometry much faster. CBgems.dae took 0.8354 seconds without acceleration and was sped up to only 0.0229 seconds. cow.dae took 21.0305 seconds without acceleration and was sped up to 0.0298 seconds. banana.dae took 8.3823 seconds without acceleration and was sped up to 0.0240 seconds. Interestingly, even though all of these meshes took very different amounts of time to render without acceleration, they take almost the exact same amount of time with acceleration. In all cases, even for CBgems.dae which is a relatively simple mesh, the acceleration substantially sped up the rendering times.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">Task 3:</span></p><p class="c2"><span class="c0">For the implementation of the uniform hemisphere sampling, we first look at the point where our ray intersects an object. We then shift our basis such that the intersection point is our origin and the z-axis is in the direction of our surface normal. In this perspective, we say we are in object space as opposed to world space. Then we uniformly sample in the unit hemisphere to find a direction to shoot some ray and calculate the radiance incoming from that sampled ray (which comes from some light source we are do not consider further bounces) multiplied by the cosine of the of the angle between the sampled ray and our surface surface (due to Lambert&rsquo;s Cosine Law) and the bsdf for our initial ray and our sampled ray at that point. In other words, we calculate the integrand from the reflection equation here:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 671.50px; height: 89.94px;"><img alt="" src="images/image6.png" style="width: 671.50px; height: 89.94px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">We take multiple samples, calculate the product above, and add all the products up. Then we divide by the number of samples and multiply by 2pi since we need to divide by the pdf which is 1/(2pi) since the surface area of the unit hemisphere is 2pi. We are just calculating the above integral&rsquo;s Monte-Carlo Estimation here </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 659.50px; height: 134.71px;"><img alt="" src="images/image38.png" style="width: 659.50px; height: 134.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">using a uniform distribution of samples from the unit hemisphere.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The implementation of importance sampling lights is very similar. However, we do the above for each light, and instead of randomly sampling from the unit hemisphere, we randomly sample from the rays that would shoot toward the light at the current step of iteration, skipping rays that intersect another object before the light source. In the case of a point light source, we only sample once since there is only one ray to sample, saving a bit of time. Our PDF for importance sampling is thus different from the PDF in uniform sampling as well, but the generation of the rays and the corresponding PDFs are handled with the lights&rsquo; sample_L method. So we compute the Monty Carlo estimation given in the equation above for each light source, then add all the estimations together for each light source to estimate incoming light after 1 bounce.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here are some comparison images using the two methods:</span></p><p class="c2"><span class="c0">From dae/sky/CBbunny.dae using 1 ray per pixel with 1 sample per ray using Uniform Sampling:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 377.00px; height: 288.27px;"><img alt="" src="images/image20.png" style="width: 437.00px; height: 365.29px; margin-left: -31.00px; margin-top: -46.73px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip; using Importance Sampling:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 474.00px; height: 366.30px;"><img alt="" src="images/image1.png" style="width: 556.00px; height: 464.33px; margin-left: -45.00px; margin-top: -61.70px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">From dae/sky/CBspheres-lambertian.dae using 32 rays per pixel using 32 samples per ray using Uniform Sampling:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 464.00px; height: 346.88px;"><img alt="" src="images/image16.png" style="width: 676.00px; height: 696.83px; margin-left: -105.00px; margin-top: -183.83px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip; using importance sampling:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 339.84px;"><img alt="" src="images/image42.png" style="width: 676.00px; height: 696.79px; margin-left: -106.00px; margin-top: -188.79px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">And here is dae/sky/CBspheres_lambertian.dae rendered using 1 ray per pixel and varying levels of samples per pixel using importance sampling:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here is 1 sample per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 347.00px;"><img alt="" src="images/image21.png" style="width: 676.00px; height: 697.11px; margin-left: -108.00px; margin-top: -184.86px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">4 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 341.41px;"><img alt="" src="images/image11.png" style="width: 676.00px; height: 697.56px; margin-left: -107.00px; margin-top: -188.56px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">16 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 463.00px; height: 343.98px;"><img alt="" src="images/image10.png" style="width: 676.00px; height: 696.97px; margin-left: -106.00px; margin-top: -186.97px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">64 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 463.00px; height: 347.55px;"><img alt="" src="images/image15.png" style="width: 676.00px; height: 696.39px; margin-left: -106.00px; margin-top: -184.39px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">As you can see, the soft shadows in which only some of the light source falls on a point become a lot less noisy as we increase the samples per pixel. This is because at the points where we have a soft shadow when we randomly shoot rays at the light source, those rays may intersect the spheres before the light source or they may intersect the light source first. With a low number of samples, this means we see a lot of variance and some pixels appear darker than they should and some lighter. As we increase the number of samples, we see less variance, and the pixels in the soft shadow appear much closer to their true value we would compute using the true integral rather than our approximation.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">As for the difference between uniform sampling and importance sampling, we see that importance sampling will almost always see better results for the sample amount of rays per pixel and samples per ray. By that, I mean that we see less noise (random black and white spots) in our image. As such, our images look much clearer with importance sampling without increasing our computation overhead too much. This is especially clear when we only use 1 ray per pixel and 1 sample per ray, as in the first set of pictures in the write-up. Using uniform sampling over the hemisphere, we see seemingly completely random noise. With importance sampling, we see a much clearer picture. We do see some noise using importance sampling, especially in our soft shadows under the bunny which are 100% black or 100% white rather than a gray. Overall, importance sampling works much better than uniform random sampling as the variance of sampled light is much lower using importance sampling than with uniform.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Task 4:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c3">Bullet point 1:</span></p><p class="c2"><span class="c0">We implemented the indirect light function recursively. For one given call with some ray and intersection, we&rsquo;d like to find the radiance for, we find the lighting from one bounce (implemented in a previous task). Then, if our ray depth is not too low and we do not randomly terminate (from Russian Roulette), we sample an incoming direction and generate a new ray with direction as the negative of the sampled direction and origin at the intersection point and a ray depth that is one smaller than the current depth. Then, we recursively compute the amount of light coming from that right by calling the indirect light function again and multiply by the appropriate scaling terms account for Lambert&rsquo;s cosine law, the bsdf between our incoming ray and the outgoing ray, and divide by the pdf for our sampled ray and divide by 1 minus the chance of termination. We add this recursive call multiplied by these scaling terms to our lighting from one bounce and return. There is also bit of book-keeping involved with checking that we accumulate or not according to isAccumBounces that we do by checking that isAccumBounces is true, and if it&rsquo;s not, we check that we are about to terminate because our depth is too low.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">Bullet point 2</span><span class="c0">&nbsp;- Here is with global illumination using 1024 samples per pixel on dae/sky/CBspheres_lamberian.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 343.62px;"><img alt="" src="images/image3.png" style="width: 400.00px; height: 399.59px; margin-left: 0.00px; margin-top: -28.59px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip; and on dae/sky/CBbunny.dae</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 342.98px;"><img alt="" src="images/image25.png" style="width: 400.00px; height: 399.98px; margin-left: 0.00px; margin-top: -27.98px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Bullet point 3:</span></p><p class="c2"><span class="c0">Here is dae/sky/CBspheres_lambertian.dae using 1024 samples using only direct illumination:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 464.00px; height: 345.54px;"><img alt="" src="images/image34.png" style="width: 480.00px; height: 359.53px; margin-left: -8.00px; margin-top: -6.53px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip; and with only indirect illumination:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 466.00px; height: 344.51px;"><img alt="" src="images/image26.png" style="width: 480.00px; height: 359.50px; margin-left: -8.00px; margin-top: -6.50px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">As we can see, with direct illumination, lighting is very uneven. There is a lot of light coming from the overhead light, the walls, and the tops of the sphere, but very dark underneath. In the indirect lighting image, lighting is very evenly spread out. There is some shadow underneath the spheres, but overall the whole image is very muted and non-contrastive in the bottom image and even lighting throughout.<br></span></p><p class="c2"><span class="c4">Bullet point 4:</span><span><br>Here is the render for dae/sky/CBbunny.dae with no bounce accumulation with max_ray_depth = 0:<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 456.00px; height: 411.29px;"><img alt="" src="images/image32.png" style="width: 800.00px; height: 800.77px; margin-left: -174.00px; margin-top: -220.46px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 1:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 460.00px; height: 348.61px;"><img alt="" src="images/image29.png" style="width: 800.00px; height: 799.45px; margin-left: -170.00px; margin-top: -223.39px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 2:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 345.03px;"><img alt="" src="images/image8.png" style="width: 800.00px; height: 800.05px; margin-left: -169.00px; margin-top: -226.97px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 3:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 349.46px;"><img alt="" src="images/image35.png" style="width: 800.00px; height: 800.64px; margin-left: -168.00px; margin-top: -224.54px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 4:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 468.00px; height: 349.89px;"><img alt="" src="images/image12.png" style="width: 800.00px; height: 799.85px; margin-left: -165.00px; margin-top: -225.11px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 5:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 460.00px; height: 342.32px;"><img alt="" src="images/image14.png" style="width: 800.00px; height: 800.45px; margin-left: -170.00px; margin-top: -226.68px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Notice that the m=0 case only shows the light on the ceiling. The m=1 case only shows things that are in direct light. Interestingly, the m=2 case lights up parts of the image that are not in direct light, e.g. the underside of the rabbit&rsquo;s torso, the bottom of the rabbit&rsquo;s face, the shadow below the rabbit, the ceiling, etc. But note that many areas of the image that are in direct light are not lit in this image (e.g. the top of the rabbit&rsquo;s head, back, and tail, etc.). But, the m=3 case lights up these areas, but also lights up some parts of the image that are in darkness. However, the m=3 case does not light up every part of the mesh: areas that are really hard to see are still dark, e.g. right underneath the rabbit or in nooks and crannies in the rabbit&rsquo;s mesh, Both these layers, m=2 and m=3 add an element of realism to the image. Firstly, the m=2 layer add much realism by adding some ambient light to dark parts of the image. But the m=3 layer also adds realism by adding a more broad ambient light over the entire scene, except for very dark places. This emphasizes the deep shadows in nooks and crannies of the mesh that are not apparent from either simply direct lighting (m=1) or m=2, since these cases also have other areas of the image in darkness. These layers give raytracing an element of realism that is very difficult to achieve with rasterization.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">Bullet point 5:</span><span class="c0"><br></span></p><p class="c2"><span class="c0">Here is the render for dae/sky/CBbunny.dae with bounce accumulation and Russian roulette on with variable max_ray_depth:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 0:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image27.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 1:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image31.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 2:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image40.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 3:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image44.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 4:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image2.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">max_ray_depth = 5:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image30.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">As we can see from the above, increasing the maximum ray depth increases the fidelity/realism of the image. With a maximum ray depth of 0, we can only see the light and nothing else. When we increase it to 1, we can see the scene, but it still does not look very realistic because much of the scene is in complete darkness, even though there should be some ambient light. Then when we increase it to 2, the entire scene gets cast in ambient light, which makes the image look much more realistic. As we continue to increase the maximum ray depth beyond 2, the lighting gets more ambient over the entire image and the shadows become softer. These changes are subtle but do slightly increase the realism of the images.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Bullet point 6:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here is the render for dae/sky/CBbunny.dae with bounce accumulation and Russian roulette with max_ray_depth = 0:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span>&hellip;max_ray_depth = 1:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image23.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 2:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image37.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 3:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image41.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 4:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image28.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&hellip;max_ray_depth = 100:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image18.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Bullet Point 7:</span></p><p class="c2"><span class="c0">Here is dae/sky/CBspheres_lambertian.dae with 4 light rays using 1 sample per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 344.92px;"><img alt="" src="images/image24.png" style="width: 1080.43px; height: 1080.30px; margin-left: -309.43px; margin-top: -368.30px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 2 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 345.28px;"><img alt="" src="images/image47.png" style="width: 1080.39px; height: 1080.70px; margin-left: -308.39px; margin-top: -365.70px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 4 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 347.35px;"><img alt="" src="images/image4.png" style="width: 1080.48px; height: 1079.40px; margin-left: -308.00px; margin-top: -364.65px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 8 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 343.01px;"><img alt="" src="images/image19.png" style="width: 1080.48px; height: 1080.38px; margin-left: -309.00px; margin-top: -367.38px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 16 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 345.37px;"><img alt="" src="images/image5.png" style="width: 1080.39px; height: 1079.33px; margin-left: -308.39px; margin-top: -365.33px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 64 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 459.00px; height: 346.27px;"><img alt="" src="images/image7.png" style="width: 1080.48px; height: 1079.73px; margin-left: -311.00px; margin-top: -367.73px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">&hellip;using 1024 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.00px; height: 347.09px;"><img alt="" src="images/image36.png" style="width: 1080.43px; height: 1080.46px; margin-left: -309.43px; margin-top: -366.46px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">As we can see, using very few samples per pixel values with few samples per light (l = 4) means we see very noisy images. This is because on a bounce, for indirect lighting, we sample all light rays in the unit hemisphere relatively equally (following a cosine hemisphere distribution), so we are likely to receive hugely varies estimations of radiance for each ray. As such, when we take very few samples, we see a ton of noise. Increasing the samples per pixel means that we take an average of many sets of these ray samples and cut down on the variance light per pixel by a large amount. As such, when we increase the samples per pixel, we see much less noise.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3">Task 5:</span></p><p class="c1"><span class="c3"></span></p><p class="c2"><span class="c0">Our implementation of adaptive sampling is as follows: For each pixel we sample at most ns_aa rays through the pixel. On every sample, we accumulate the radiance vector. We also accumulate a variable s2 with the squared illuminance of every sample. Every samplesPerBatch samples, we compute a few relevant quantities: a) s1 is the illuminance of the accumulated radiance, b) the mean is s1 / n, where n is the total number of samples so far, c) the variance is (s2 - (s1^2 / n)) / (n - 1), d) I = 1.96 * sqrt(variance / n). If I &lt;= maxTolerance * mean, we break early. After finishing this loop (whether we broke early or did all ns_aa samples), we still have stored n as the total number of samples we actually computed. We will divide the accumulated radiance vector by n to have it be the average radiance of all samples. We also store n in a sampleCountBuffer so that it can be displayed in the rate image.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Here is the render of dae/sky/CBspheres_lambertian.dae with adaptive sampling:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image46.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">And here is the rate image for this render:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image48.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">You can see that different parts of the image have different sampling rates. For example, the parts of the ball in shadow have high sampling rates (which means they were slow to converge), but the area in full light have low sampling rates (which means they were quick to converge).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">Short Partner Paragraph</span><span class="c0">:</span></p><p class="c2"><span class="c0">Overall, the partnership worked well. We generally worked together, one working on the write-up for the section that person did while the other worked on another section. We made sure to understand the relevant code sections, what the question was asking, and the other&rsquo;s ideas about the problem so we could help each other with debugging. Overall, the partnership worked well and we learned a lot about how computers produce photorealistic images from a practical point of view rather than full theory.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p></body></html>